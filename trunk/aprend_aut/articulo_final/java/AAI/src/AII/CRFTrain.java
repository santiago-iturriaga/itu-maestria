package AII;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;

import java.util.ArrayList;
import java.util.Random;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import cc.mallet.types.Alphabet;
import cc.mallet.types.AugmentableFeatureVector;
import cc.mallet.types.FeatureVector;
import cc.mallet.types.FeatureVectorSequence;
import cc.mallet.types.Instance;
import cc.mallet.types.InstanceList;
import cc.mallet.types.LabelAlphabet;
import cc.mallet.types.LabelSequence;
import cc.mallet.types.Sequence;

import cc.mallet.fst.CRF;
import cc.mallet.fst.CRFTrainerByLabelLikelihood;
import cc.mallet.fst.MaxLatticeDefault;
import cc.mallet.fst.Transducer;
import cc.mallet.fst.TransducerEvaluator;
import cc.mallet.fst.ViterbiWriter;
import cc.mallet.pipe.Pipe;
import cc.mallet.pipe.iterator.LineGroupIterator;

import cc.mallet.util.CommandOption;
import cc.mallet.util.MalletLogger;

public class CRFTrain {
	private static Logger logger = MalletLogger.getLogger(CRFTrain.class
			.getName());

	private CRFTrain() {
	}

	/**
	 * Converts an external encoding of a sequence of elements with binary
	 * features to a {@link FeatureVectorSequence}. If target processing is on
	 * (training or labeled test data), it extracts element labels from the
	 * external encoding to create a target {@link LabelSequence}. Two external
	 * encodings are supported:
	 * <ol>
	 * <li>A {@link String} containing lines of whitespace-separated tokens.</li>
	 * <li>a {@link String}<code>[][]</code>.</li>
	 * </ol>
	 * 
	 * Both represent rows of tokens. When target processing is on, the last
	 * token in each row is the label of the sequence element represented by
	 * this row. All other tokens in the row, or all tokens in the row if not
	 * target processing, are the names of features that are on for the sequence
	 * element described by the row.
	 * 
	 */
	public static class SimpleTaggerSentence2FeatureVectorSequence extends Pipe {
		// gdruck
		// Previously, there was no serialVersionUID. This is ID that would
		// have been automatically generated by the compiler. Therefore,
		// other changes should not break serialization.
		private static final long serialVersionUID = -2059308802200728625L;

		/**
		 * Creates a new <code>SimpleTaggerSentence2FeatureVectorSequence</code>
		 * instance.
		 */
		public SimpleTaggerSentence2FeatureVectorSequence() {
			super(new Alphabet(), new LabelAlphabet());
		}

		/**
		 * Parses a string representing a sequence of rows of tokens into an
		 * array of arrays of tokens.
		 * 
		 * @param sentence
		 *            a <code>String</code>
		 * @return the corresponding array of arrays of tokens.
		 */
		private String[][] parseSentence(String sentence) {
			String[] lines = sentence.split("\n");
			String[][] tokens = new String[lines.length][];
			for (int i = 0; i < lines.length; i++)
				tokens[i] = lines[i].split(" ");
			return tokens;
		}

		public Instance pipe(Instance carrier) {
			Object inputData = carrier.getData();
			Alphabet features = getDataAlphabet();
			LabelAlphabet labels;
			LabelSequence target = null;
			String[][] tokens;

			if (inputData instanceof String)
				tokens = parseSentence((String) inputData);
			else if (inputData instanceof String[][])
				tokens = (String[][]) inputData;
			else
				throw new IllegalArgumentException(
						"Not a String or String[][]; got " + inputData);

			FeatureVector[] fvs = new FeatureVector[tokens.length];
			if (isTargetProcessing()) {
				labels = (LabelAlphabet) getTargetAlphabet();
				target = new LabelSequence(labels, tokens.length);
			}

			for (int l = 0; l < tokens.length; l++) {
				int nFeatures;

				if (isTargetProcessing()) {
					if (tokens[l].length < 1)
						throw new IllegalStateException(
								"Missing label at line " + l + " instance "
										+ carrier.getName());
					nFeatures = tokens[l].length - 1;
					target.add(tokens[l][nFeatures]);
				} else {
					nFeatures = tokens[l].length;
				}

				ArrayList<Integer> featureIndices = new ArrayList<Integer>();
				for (int f = 0; f < nFeatures; f++) {
					int featureIndex = features.lookupIndex(tokens[l][f]);
					// gdruck
					// If the data alphabet's growth is stopped, featureIndex
					// will be -1. Ignore these features.
					if (featureIndex >= 0) {
						featureIndices.add(featureIndex);
					}
				}

				int[] featureIndicesArr = new int[featureIndices.size()];
				for (int index = 0; index < featureIndices.size(); index++) {
					featureIndicesArr[index] = featureIndices.get(index);
				}
		       	fvs[l] = new FeatureVector(features, featureIndicesArr);
			}

			carrier.setData(new FeatureVectorSequence(fvs));

			if (isTargetProcessing()) {
				carrier.setTarget(target);
			} else {
				carrier.setTarget(new LabelSequence(getTargetAlphabet()));
			}

			return carrier;
		}
	}

	/**
	 * Create and train a CRF model from the given training data, optionally
	 * testing it on the given test data.
	 * 
	 * @param training
	 *            training data
	 * @param testing
	 *            test data (possibly <code>null</code>)
	 * @param eval
	 *            accuracy evaluator (possibly <code>null</code>)
	 * @param orders
	 *            label Markov orders (main and backoff)
	 * @param defaultLabel
	 *            default label
	 * @param forbidden
	 *            regular expression specifying impossible label transitions
	 *            <em>current</em><code>,</code><em>next</em> (<code>null</code>
	 *            indicates no forbidden transitions)
	 * @param allowed
	 *            regular expression specifying allowed label transitions (
	 *            <code>null</code> indicates everything is allowed that is not
	 *            forbidden)
	 * @param connected
	 *            whether to include even transitions not occurring in the
	 *            training data.
	 * @param iterations
	 *            number of training iterations
	 * @param var
	 *            Gaussian prior variance
	 * @return the trained model
	 */
	public static CRF train(InstanceList training, InstanceList testing,
			int[] orders, String defaultLabel,
			String forbidden, String allowed, boolean connected,
			int iterations, double var, CRF crf) {

		Pattern forbiddenPat = Pattern.compile(forbidden);
		Pattern allowedPat = Pattern.compile(allowed);

		if (crf == null) {
			crf = new CRF(training.getPipe(), (Pipe) null);
			
			String startName = crf.addOrderNStates(training, orders, null,
					defaultLabel, forbiddenPat, allowedPat, connected);
			
			for (int i = 0; i < crf.numStates(); i++)
				crf.getState(i).setInitialWeight(Transducer.IMPOSSIBLE_WEIGHT);
			
			crf.getState(startName).setInitialWeight(0.0);
		}
		
		logger.info("Training on " + training.size() + " instances");
		
		if (testing != null)
			logger.info("Testing on " + testing.size() + " instances");

		CRFTrainerByLabelLikelihood crft = new CRFTrainerByLabelLikelihood(crf);
		crft.setGaussianPriorVariance(var);
		crft.setUseSparseWeights(true);
		crft.setUseSomeUnsupportedTrick(true);

		boolean converged;
		for (int i = 1; i <= iterations; i++) {
			converged = crft.train(training, 1);

			if (converged)
				break;
		}

		return crf;
	}

	public static void main(String[] args) throws Exception {
		String corpus = "corpus/train_2.txt";
		String model = "corpus/prueba_crf_2.model";

		Reader trainingFile = null;
		trainingFile = new FileReader(new File(corpus));

		Pipe p = null;
		p = new SimpleTaggerSentence2FeatureVectorSequence();
		p.getTargetAlphabet().lookupIndex("O");
		p.setTargetProcessing(true);

		InstanceList trainingData = null;
		trainingData = new InstanceList(p);
		trainingData.addThruPipe(new LineGroupIterator(trainingFile, Pattern
				.compile("^\\s*$"), true));

		logger.info("Number of features in training data: "
				+ p.getDataAlphabet().size());

		if (p.isTargetProcessing()) {
			Alphabet targets = p.getTargetAlphabet();
			StringBuffer buf = new StringBuffer("Labels:");
			for (int i = 0; i < targets.size(); i++)
				buf.append(" ").append(targets.lookupObject(i).toString());
			logger.info(buf.toString());
		}

		int[] list_of_label_Markov_orders = {1,2};
		int iterations = 500;
		
		CRF crf = null;
		crf = train(trainingData, null, list_of_label_Markov_orders, "O",
				"\\s", ".*", true, iterations,
				10, crf);

		ObjectOutputStream s = new ObjectOutputStream(new FileOutputStream(
				model));
		s.writeObject(crf);
		s.close();
	}
}
