package AII;
/* Copyright (C) 2003 University of Pennsylvania.
   This file is part of "MALLET" (MAchine Learning for LanguagE Toolkit).
http://www.cs.umass.edu/~mccallum/mallet
This software is provided under the terms of the Common Public License,
version 1.0, as published by http://www.opensource.org.  For further
information, see the file `LICENSE' included with this distribution. */

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;

import java.util.ArrayList;
import java.util.Random;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import cc.mallet.types.Alphabet;
import cc.mallet.types.AugmentableFeatureVector;
import cc.mallet.types.FeatureVector;
import cc.mallet.types.FeatureVectorSequence;
import cc.mallet.types.Instance;
import cc.mallet.types.InstanceList;
import cc.mallet.types.LabelAlphabet;
import cc.mallet.types.LabelSequence;
import cc.mallet.types.Sequence;

import cc.mallet.fst.CRF;
import cc.mallet.fst.CRFTrainerByLabelLikelihood;
import cc.mallet.fst.MaxLatticeDefault;
import cc.mallet.fst.Transducer;
import cc.mallet.fst.TransducerEvaluator;
import cc.mallet.fst.ViterbiWriter;
import cc.mallet.pipe.Pipe;
import cc.mallet.pipe.iterator.LineGroupIterator;

import cc.mallet.util.CommandOption;
import cc.mallet.util.MalletLogger;

/**
 * This class's main method trains, tests, or runs a generic CRF-based sequence
 * tagger.
 * <p>
 * Training and test files consist of blocks of lines, one block for each
 * instance, separated by blank lines. Each block of lines should have the first
 * form specified for the input of
 * {@link SimpleTaggerSentence2FeatureVectorSequence}. A variety of command line
 * options control the operation of the main program, as described in the
 * comments for {@link #main main}.
 * 
 * @author Fernando Pereira <a
 *         href="mailto:pereira@cis.upenn.edu">pereira@cis.upenn.edu</a>
 * @version 1.0
 */
public class CRFTagger {
	private static Logger logger = MalletLogger.getLogger(CRFTagger.class
			.getName());

	/**
	 * No <code>SimpleTagger</code> objects allowed.
	 */
	private CRFTagger() {
	}

	/**
	 * Converts an external encoding of a sequence of elements with binary
	 * features to a {@link FeatureVectorSequence}. If target processing is on
	 * (training or labeled test data), it extracts element labels from the
	 * external encoding to create a target {@link LabelSequence}. Two external
	 * encodings are supported:
	 * <ol>
	 * <li>A {@link String} containing lines of whitespace-separated tokens.</li>
	 * <li>a {@link String}<code>[][]</code>.</li>
	 * </ol>
	 * 
	 * Both represent rows of tokens. When target processing is on, the last
	 * token in each row is the label of the sequence element represented by
	 * this row. All other tokens in the row, or all tokens in the row if not
	 * target processing, are the names of features that are on for the sequence
	 * element described by the row.
	 * 
	 */
	public static class SimpleTaggerSentence2FeatureVectorSequence extends Pipe {
		// gdruck
		// Previously, there was no serialVersionUID. This is ID that would
		// have been automatically generated by the compiler. Therefore,
		// other changes should not break serialization.
		private static final long serialVersionUID = -2059308802200728625L;

		/**
		 * Creates a new <code>SimpleTaggerSentence2FeatureVectorSequence</code>
		 * instance.
		 */
		public SimpleTaggerSentence2FeatureVectorSequence() {
			super(new Alphabet(), new LabelAlphabet());
		}

		/**
		 * Parses a string representing a sequence of rows of tokens into an
		 * array of arrays of tokens.
		 * 
		 * @param sentence
		 *            a <code>String</code>
		 * @return the corresponding array of arrays of tokens.
		 */
		private String[][] parseSentence(String sentence) {
			String[] lines = sentence.split("\n");
			String[][] tokens = new String[lines.length][];
			for (int i = 0; i < lines.length; i++)
				tokens[i] = lines[i].split(" ");
			return tokens;
		}

		public Instance pipe(Instance carrier) {
			Object inputData = carrier.getData();
			Alphabet features = getDataAlphabet();
			LabelAlphabet labels;
			LabelSequence target = null;
			String[][] tokens;
			
			if (inputData instanceof String)
				tokens = parseSentence((String) inputData);
			else if (inputData instanceof String[][])
				tokens = (String[][]) inputData;
			else
				throw new IllegalArgumentException(
						"Not a String or String[][]; got " + inputData);
			
			FeatureVector[] fvs = new FeatureVector[tokens.length];
			if (isTargetProcessing()) {
				labels = (LabelAlphabet) getTargetAlphabet();
				target = new LabelSequence(labels, tokens.length);
			}
			
			for (int l = 0; l < tokens.length; l++) {
				int nFeatures;
				
				if (isTargetProcessing()) {
					if (tokens[l].length < 1)
						throw new IllegalStateException(
								"Missing label at line " + l + " instance "
										+ carrier.getName());
					nFeatures = tokens[l].length - 1;
					target.add(tokens[l][nFeatures]);
				} else {
					nFeatures = tokens[l].length;
				}
				
				ArrayList<Integer> featureIndices = new ArrayList<Integer>();
				for (int f = 0; f < nFeatures; f++) {
					int featureIndex = features.lookupIndex(tokens[l][f]);
					// gdruck
					// If the data alphabet's growth is stopped, featureIndex
					// will be -1. Ignore these features.
					if (featureIndex >= 0) {
						featureIndices.add(featureIndex);
					}
				}
				
				int[] featureIndicesArr = new int[featureIndices.size()];
				for (int index = 0; index < featureIndices.size(); index++) {
					featureIndicesArr[index] = featureIndices.get(index);
				}
				
				fvs[l] = false ? new AugmentableFeatureVector(
						features, featureIndicesArr, null,
						featureIndicesArr.length) : new FeatureVector(features,
						featureIndicesArr);
						/*
						 * Whether to perform feature induction during training
						 */
			}
			
			carrier.setData(new FeatureVectorSequence(fvs));
			
			if (isTargetProcessing()) {
				carrier.setTarget(target);
			} else {
				carrier.setTarget(new LabelSequence(getTargetAlphabet()));
			}
			
			return carrier;
		}
	}

	/**
	 * Create and train a CRF model from the given training data, optionally
	 * testing it on the given test data.
	 * 
	 * @param training
	 *            training data
	 * @param testing
	 *            test data (possibly <code>null</code>)
	 * @param eval
	 *            accuracy evaluator (possibly <code>null</code>)
	 * @param orders
	 *            label Markov orders (main and backoff)
	 * @param defaultLabel
	 *            default label
	 * @param forbidden
	 *            regular expression specifying impossible label transitions
	 *            <em>current</em><code>,</code><em>next</em> (<code>null</code>
	 *            indicates no forbidden transitions)
	 * @param allowed
	 *            regular expression specifying allowed label transitions (
	 *            <code>null</code> indicates everything is allowed that is not
	 *            forbidden)
	 * @param connected
	 *            whether to include even transitions not occurring in the
	 *            training data.
	 * @param iterations
	 *            number of training iterations
	 * @param var
	 *            Gaussian prior variance
	 * @return the trained model
	 */
	public static CRF train(InstanceList training, InstanceList testing,
			TransducerEvaluator eval, int[] orders, String defaultLabel,
			String forbidden, String allowed, boolean connected,
			int iterations, double var, CRF crf) {
		
		Pattern forbiddenPat = Pattern.compile(forbidden);
		Pattern allowedPat = Pattern.compile(allowed);
		
		if (crf == null) {
			crf = new CRF(training.getPipe(), (Pipe) null);
			String startName = crf.addOrderNStates(training, orders, null,
					defaultLabel, forbiddenPat, allowedPat, connected);
			for (int i = 0; i < crf.numStates(); i++)
				crf.getState(i).setInitialWeight(Transducer.IMPOSSIBLE_WEIGHT);
			crf.getState(startName).setInitialWeight(0.0);
		}
		logger.info("Training on " + training.size() + " instances");
		if (testing != null)
			logger.info("Testing on " + testing.size() + " instances");

		CRFTrainerByLabelLikelihood crft = new CRFTrainerByLabelLikelihood(
				crf);
		crft.setGaussianPriorVariance(var);

//		if (weightsOption.value.equals("dense")) {
//			crft.setUseSparseWeights(false);
//			crft.setUseSomeUnsupportedTrick(false);
//		} else if (weightsOption.value.equals("some-dense")) {
			crft.setUseSparseWeights(true);
			crft.setUseSomeUnsupportedTrick(true);
//		} else if (weightsOption.value.equals("sparse")) {
//			crft.setUseSparseWeights(true);
//			crft.setUseSomeUnsupportedTrick(false);
//		} else {
//			throw new RuntimeException("Unknown weights option: "
//					+ weightsOption.value);
//		}

		boolean converged;
		for (int i = 1; i <= iterations; i++) {
			converged = crft.train(training, 1);
			
			if (i % 1 == 0 && eval != null) { 
				// Change the 1 to higher integer to evaluate less often
				eval.evaluate(crft);
			}
			
			if (converged)
				break;
		}

		return crf;
	}

	public static void main(String[] args) throws Exception {
		String corpus = "corpus.txt";
		String model = "crf.model";
		
		Reader trainingFile = null, testFile = null;
		InstanceList trainingData = null, testData = null;

		trainingFile = new FileReader(new File(corpus));

		Pipe p = null;
		p = new SimpleTaggerSentence2FeatureVectorSequence();
		p.getTargetAlphabet().lookupIndex("O");

		CRF crf = null;		
		TransducerEvaluator eval = null;
		
		p.setTargetProcessing(true);
		
		trainingData = new InstanceList(p);
		trainingData.addThruPipe(new LineGroupIterator(trainingFile,
				Pattern.compile("^\\s*$"), true));
		
		logger.info("Number of features in training data: "
				+ p.getDataAlphabet().size());

		if (p.isTargetProcessing()) {
			Alphabet targets = p.getTargetAlphabet();
			StringBuffer buf = new StringBuffer("Labels:");
			for (int i = 0; i < targets.size(); i++)
				buf.append(" ").append(targets.lookupObject(i).toString());
			logger.info(buf.toString());
		}
		
//		crf = train(trainingData, testData, eval, ordersOption.value,
//				"O", null,
//				null, connectedOption.value,
//				iterationsOption.value, gaussianVarianceOption.value, crf);
//		
//		ObjectOutputStream s = new ObjectOutputStream(
//				new FileOutputStream(model));
//		s.writeObject(crf);
//		s.close();
	}
}
